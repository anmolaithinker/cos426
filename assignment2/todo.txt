Analysis
******(1) Compute average edge lengths: Compute the average length of edges attached to a vertex. This feature should be implemented first. To do it, you must design a data structure that allows O(K) access to edges attached to each vertex, where K is the number of edges attached to a vertex.
******(1) Compute per-vertex normals: Compute the surface normal at a vertex. This feature should be implemented second. To do it, you must design a data structure that allows O(K) access to faces attached to each vertex, where K is the number of faces attached to a vertex. Then, to compute the normal for a vertex, you should take a weighted average of the normals for the attached faces, where the weights are determined by the areas of the faces. Store the resulting normal in the "normal" variable associated with the vertex. You can display the computed normals by hitting the 'N' key in meshview.
(3) Compute per-vertex Gaussian curvatures: Compute an estimate of the Gaussian curvature (the product of the principal curvautures) of the surface at a vertex. You can use a method based on the Gauss Bonet Theorem, which is described in [Akleman, 2006]. Store the resulting curvature values in the "curvature" variable associated with the for every vertex. You can display the computed curvatures by hitting the 'C' key in meshview.

Warps
******(1) Random noise: Add noise of a random amount and direction to the position of every vertex, where the input parameter "factor" should be multiplied by the average length of the edges attached to the vertex to determine its maximum displacement (i.e., displacement distances should be between 0 and "factor * vertex->AverageEdgeLength()."
(1/2) Inflate: Move every vertex along its normal direction. The input parameter "factor" should be multiplied by the average length of the edges attached to the vertex to determine the displacement of each vertex along its normal direction. Note that factor can be negative, which means that the vertex should move in the direction opposite to the normal vector.
(1/2) Fun: Warp a mesh using a non-linear mapping of your choice (examples are sine, bulge, swirl).
Filters
******(2) Smooth: Smooth the mesh by moving every vertex to a position determined by a weighted average of itself and its immediate neighbors (with weights determined by a Gaussian with sigma equal to the average length of edges attached to the vertex, normalized such that the weights sum to one).
(1) Sharpen: Accentuate details in the mesh by moving every vertex along the opposite of the vector determined by a weighted average of itself and its neighbors (with weights determined by a Gaussian with sigma equal to the average length of edges attached to the vertex, normalized such that the weights sum to one). This filter moves vertices by the vector exactly opposite from the one used for Smooth().
(1) Bilateral smoothing: Smooth the mesh using a bilateral filter as in [Jones et al, Siggraph 2003].
Erosion
******(3) Truncate: For every vertex, create a new vertex a parameter t [0-0.5] of the way along each of its N attached edges, and then "chop off" the pyramid whose base is formed by the new vertices and whose apex is the original vertex, creating new planar face(s) covering the hole. It is OK to assume that the input shape is convex for this feature.
(3) Bevel: For every edge, create a new face whose vertices are t [0-0.5] of the way along each of its attached edges. This requires first truncating all vertices by t, creating new vertices t [0-0.5] of the way along each of new edges, and then "chopping off" a prism for each of the original edges, creating new planar face(s) covering the holes. It is OK to assume that the input shape is convex for this feature.

Remeshing
******(2) Split faces: Split every face into K+1 faces (where K is the number of vertices on the face). Create a new vertex at the midpoint of every edge, remove the original face, create a new face connnecting all the new vertices, and create new triangular faces connecting each vertex of the original face with the new vertices associated with its adjacent edges.
(2) Star faces: Split every face into N triangles (where N is the number of vertices on the face). That is, create a new vertex at the centroid of the face, remove the original face, create N new triangular faces connecting the new vertex with each pair of adjacent vertices of the original face. Position the new vertex at a point that is offset from the centroid of the face along the normal vector by a distance equal to factor times the average edge length for the face.
(2) Split long edges: Iteratively split edges longer than max_edge_length. Note that every edge split produces a new vertex at the edge midpoint and replaces the two adjacent faces with four. Edges should be split repeatedly until there is none longer than the given threshold. Note: an extra point will be given if longer edges are split first (which produces better shaped faces).
(3) Collapse short edges: Iteratively collapse edges shorter than min_edge_length. Note that every edge collapse merges two vertices into one and removes up to two faces (if the adjacent faces are triangles). Place the new vertex at the midpoint of the collapsed edge. Note: an extra point will be given if shorter edges are collapsed first (which produces better shaped faces).
(4) Cluster vertices: Simplify the mesh by clustering vertices residing in the same cell of a grid defined by x, y, and z spacing parameters. All vertices within the same grid cell should be merged into a single vertex, that vertex should be placed at the centroid of the cluster vertices, and all edges and faces that collapse as a result of the vertex merging should be removed.

Subdivision Surfaces
******(2) Loop subdivision: Subdivide every face using the method in SplitFaces. Then, update the positions of all vertices according to the Loop subdivision weights. This only must work correctly for meshes with triangular faces.
(3) Catmull-Clark subdivision: Subdivide every N-sided face into N quads by creating a new vertex in the center of every face connected to new vertices at the center of every edge, and then update the positions of all vertices according to the Catmull-Clark subdivision weights. This only must work correctly for meshes with quadrilateral faces.

Parametric Surfaces
(2) Bezier: Add new vertices and faces to the mesh representing uniform cubic Bezier patches. The control mesh file (specified after -bezier) should have M*N vertices representing control points arranged in a M by N array. The output file should contain the input mesh plus a fine triangular mesh with 4M * 4N vertices representing the cubic Bezier surface implied by the control points. That is, vertices at sixteen regular intervals of u and v on each 4x4 subset of the control mesh should be generated using the tensor product uniform cubic Bezier surface construction and connnected into triangles to form a polygonal approximation of the smooth Bezier surface.
(2) B-Spline: Add new vertices and faces to the mesh representing uniform cubic BSpline patches. The control mesh file (specified after -bspline) should have M*N vertices representing control points arranged in a M by N array. The output file should contain a fine triangular mesh with 4M * 4N vertices representing the cubic BSpline surface implied by the control points. That is, vertices at sixteen regular intervals of u and v on each 4x4 subset of the control mesh should be generated using the tensor product uniform cubic BSpline surface construction and connnected into triangles to form a polygonal approximation of the smooth BSpline surface.

Procedural Modeling
*****(2) Surface of revolution: Add new vertices and faces to the mesh by sweeping a profile curve around an axis of revolution. The vertices representing the profile curve are provided in the passed mesh file (take the vertices of the mesh in order and ignore the faces). The axis of revolution and rotation angle step size are provided in the arguments. New vertices should be created by successively rotating the original vertices around the axis by the step size and new faces should be constructed by connecting adjacent vertices to create a surface of revolution.
(2) Surface sweep: Create new vertices and faces by sweeping a polygon along a curve. The vertices representing a cross-section polygon are provided in the first input mesh file, and the vertices representing the sweep centerline curve are provided in the second mesh file (for both, take the vertices of the meshes in order and ignore the faces). New vertices should be created by successively translating and rotating the vertices of the cross-section polygon to match the position and orientation of vertices/edges in the centerline, and new faces should be constructed by connecting adjacent vertices created during the sweep.

Topological Fixup
(3) Fill holes: Create faces covering the holes of a mesh by connecting vertices on the boundary of every hole. You should completely cover the hole, while doing your best to produce well-shaped faces (e.g., by connecting closer vertices first).
(3) Fix cracks: Merge boundary vertices and edges within a specified distance (epsilon) of one another.
(4) Fix self-intersections: Insert edges at face-face intersections and discard the smaller part of the mesh "pinched" off by new edge loops. Note: this is hard.
Boolean Operations
(4) Intersect: Compute the mesh enclosing the intersection of two meshes. This feature requires introducing edges at every face intersection and removing parts of the mesh that lie in the exterior of the solid object implied by either of the two meshes. See [Segal 1986] for details.
(4) Difference: compute the mesh enclosing the difference of two meshes. This feature requires introducing edges at every face intersection and removing parts of the mesh that lie in the interior of the solid object implied by the second mesh.
(4) Union: compute the mesh enclosing the union of two meshes. This feature requires introducing edges at every face intersection and removing parts of the mesh that lie in the interior of the solid object implied by both of the two meshes.
(3) Implement any of the boolean operations by rasterizing the meshes onto two voxel grids, then using max(), min(), or subtraction elementwise to compute the boolean operation, then extract the isosurface to produce the final mesh.

Miscellaneous
(2) Crop: Crop the input mesh to the positive side of the plane. This feature requires clipping each polygon crossing the plane, and discarding any part of any face on the negative side of the plane.
(up to 3) Anything else: Implement any non-trivial mesh processing algorithm of your own choosing, and we will give you points according to the difficulty.